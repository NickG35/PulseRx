{% extends 'base.html' %}

{% block content %}
<script>
    document.addEventListener('DOMContentLoaded', () => {

        const input = document.querySelector('.autocomplete-message');
        const results = document.getElementById('autocompleteResults');
        let timeoutId;

        input.addEventListener('keyup', function(){
            clearTimeout(timeoutId);
            const query = this.value.trim();

            if (query.length === 0){
                results.innerHTML = '';
                return;
            }

            timeoutId = setTimeout(() => {
                fetch(`/accounts/message_search?q=${encodeURIComponent(query)}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error status: ${response.status}`);
                        }
                        return response.json()
                    })
                    .then(data => {
                        const fragment = document.createDocumentFragment();

                        if (data.length > 0) {
                            data.forEach(item => {
                                const div = document.createElement('div');
                                div.classList.add('search-message');

                                const threadUrl = `/accounts/thread/${item.thread_id}`;
                                const linkMessage = document.createElement('a');
                                linkMessage.href = `${threadUrl}#message_${item.id}`;
                                linkMessage.style.display = 'block';
                                linkMessage.textContent = item.content;
                                div.appendChild(linkMessage);

                                fragment.appendChild(div);
                            })
                        } else {
                            const div = document.createElement('div');
                            div.textContent = `No messages found.`
                            fragment.appendChild(div);
                        }

                        results.innerHTML = '';
                        results.appendChild(fragment); 
                    })
                    .catch(error => {
                        console.error(`Error fetching message data:`, error);
                        results.innerHTML = `<div class="error-message">Error loading results. Please try again.</div>`;
                    });
            }, 300);
        });

        const threadBtn = document.querySelector('.threadSearch');
        threadBtn.addEventListener('click', function(){
            peopleInput.style.display = 'block';
        })

        window.addEventListener("pageshow", function (event) {
            if (event.persisted || performance.getEntriesByType("navigation")[0].type === "back_forward") {
                const hiddenPatient = document.querySelector(".hidden-patient");
                if (hiddenPatient) hiddenPatient.value = "";
                document.querySelector('.autocomplete-message').value = "";
                document.getElementById("autocomplete-people").value = "";
            }
        });

        // Listen for new notifications from base.html
        document.addEventListener('newNotification', (event) => {
            const notification = event.detail;

            // Only handle message notifications (not reminders or system notifications)
            if (notification.thread_id && notification.message_id && !notification.type) {
                updateOrCreateThread(notification);
            }
        });

        function updateOrCreateThread(notification) {
            const threadBox = document.getElementById(`thread_${notification.thread_id}`);

            if (threadBox) {
                // Thread exists - update it
                updateThreadPreview(notification, threadBox);
            } else {
                // Thread doesn't exist - create it
                createNewThread(notification);
            }
        }

        function updateThreadPreview(notification, threadBox) {
            // Update the message content
            const messageContent = threadBox.querySelector('.message-content');
            if (messageContent) {
                messageContent.textContent = notification.content;
            }

            // Update the sender
            const senderSpan = threadBox.querySelector('.message-box span');
            if (senderSpan) {
                const isMe = notification.sender === "{{ request.user.first_name }} {{ request.user.last_name }}";
                senderSpan.textContent = isMe ? 'Me:' : `${notification.sender}:`;
            }

            // Update the timestamp
            const messageTimestamp = threadBox.querySelector('.message-timestamp small');
            if (messageTimestamp) {
                messageTimestamp.textContent = notification.timestamp;
            }

            // Move thread to top
            const threadsBox = document.getElementById('threads-box');
            const threadLink = threadBox.closest('a');
            if (threadsBox && threadLink) {
                threadsBox.insertBefore(threadLink, threadsBox.firstChild);
            }
        }

        function createNewThread(notification) {
            const threadsBox = document.getElementById('threads-box');
            const noMessage = document.getElementById('noMessage');

            if (!threadsBox) return;

            // Determine thread name based on user role and notification data
            let threadName = notification.sender;

            // Create new thread element
            const threadLink = document.createElement('a');
            threadLink.href = `/accounts/thread/${notification.thread_id}`;

            const threadDiv = document.createElement('div');
            threadDiv.className = 'thread-box';
            threadDiv.id = `thread_${notification.thread_id}`;

            const messageBox = document.createElement('div');
            messageBox.className = 'message-box';
            messageBox.id = `message_${notification.message_id}`;

            const isMe = notification.sender === "{{ request.user.first_name }} {{ request.user.last_name }}";

            messageBox.innerHTML = `
                <p class="message-sender">
                    <strong>${threadName}</strong>
                </p>
                <span>${isMe ? 'Me:' : notification.sender + ':'}</span>
                <p class="message-content">${notification.content}</p>
                <p class="message-timestamp"><small>${notification.timestamp}</small></p>
            `;

            threadDiv.appendChild(messageBox);
            threadLink.appendChild(threadDiv);

            // Insert at top of threads list
            threadsBox.insertBefore(threadLink, threadsBox.firstChild);

            // Hide "No messages yet" message
            if (noMessage) {
                noMessage.style.display = 'none';
            }
        }
    });
</script>
<p>These are my pharmacy messages</p>


    <input placeholder="search messages..." type="text" class="autocomplete-message">
    <div id="autocompleteResults"></div>

    {% if request.user.role == 'patient' %}
        <form action="{% url 'patient_thread' %}" method="post" style="display:inline;">
            {% csrf_token %}
            <input type="hidden" name="patientID" value="{{ patient.id }}">
            <button type="submit"><i class="fa-regular fa-pen-to-square"></i></button>
        </form>
    {% else %}
        <button class="threadSearch" type="button"><i class="fa-regular fa-pen-to-square"></i></button>
        <form action="{% url 'patient_thread' %}" method="post">
            {% csrf_token %}
            <input placeholder="search for patients..." type="text" id="autocomplete-people" class="autocomplete-input" data-type="patient" data-url="{% url 'patient_search' %}">
            <input name="patientID" type="hidden" class="hidden-patient">
            <div class="autocompletePeople" id="autocompleteResults-patient"></div>
            <button type="submit">Search</button>
        </form>
    {% endif %}

<div id="threads-box">
    {% for thread in threads %}
    <a href="{% url 'threads' thread_id=thread.id %}">
        <div class="thread-box" id="thread_{{ thread.id }}">
            {% with latest=thread.latest_message %}
                    <div class="message-box"  {% if latest %} id="message_{{ latest.id }}" {% endif %}>
                        <p class="message-sender">
                            <strong>
                                {% for user in thread.other_participants %}
                                    {% if user.role == "pharmacy admin" or user.role == "pharmacist" %}
                                        {{ user.pharmacyprofile.pharmacy_name }} Pharmacy
                                    {% else %}
                                        {{ user.first_name }} {{ user.last_name }}
                                    {% endif %}
                                {% endfor %}
                            </strong>
                        </p>
                        
                        {% if latest %}
                            {% if latest.sender == request.user %}
                                <span>Me:</span>
                            {% else %}
                                <span>{{ latest.sender.first_name }} {{ latest.sender.last_name }}:</span>
                            {% endif %}

                            <p class="message-content">{{ latest.content }}</p>
                            <p class="message-timestamp"><small>{{ latest.timestamp }}</small></p>
                        {% else %}
                            <p class="message-content">No messages yet</p>
                            <p class="message-timestamp"><small>{{ thread.created_at }}</small></p>
                        {% endif %}
                    </div>
            {% endwith %}
        </div>
    </a>
{% endfor %}
    <p id="noMessage" {% if threads %} style="display: none;" {% endif %}>No messages yet.</p>
</div>
{% endblock %}